name: Update Submodules and Remove Stale Entries

on:
  workflow_dispatch:
  schedule:
    # Run every Monday at 2 AM UTC
    - cron: '0 2 * * 1'

permissions:
  contents: write

jobs:
  update-submodules:
    runs-on: ubuntu-latest
    env:
      END_DATE: "2025-02-28"   # Last date where this workflow should still do work (UTC)
    steps:
      - name: Check end date
        run: |
          set -e
          NOW_DATE="$(date -u +%Y-%m-%d)"
          echo "Current UTC date: $NOW_DATE"
          echo "End date:        $END_DATE"

          # If today is after END_DATE, exit without doing anything
          if [[ "$NOW_DATE" > "$END_DATE" ]]; then
            echo "End date has passed. Skipping submodule update."
            exit 0
          fi

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update submodules and remove stale entries
        id: update
        run: |
          set -e
          
          echo "Processing submodules..."
          CHANGES_MADE=false
          STALE_SUBMODULES=()
          REMOVED_COUNT=0
          
          # Check if .gitmodules exists
          if [ ! -f .gitmodules ]; then
            echo "No .gitmodules file found. Nothing to update."
            exit 0
          fi
          
          # Parse submodules from .gitmodules into an array
          mapfile -t SUBMODULES < <(git config --file .gitmodules --get-regexp path | awk '{ print $2 }')
          
          if [ ${#SUBMODULES[@]} -eq 0 ]; then
            echo "No submodules configured."
            exit 0
          fi
          
          for SUBMODULE_PATH in "${SUBMODULES[@]}"; do
            echo "----------------------------------------"
            echo "Processing submodule: $SUBMODULE_PATH"
            
            # Get submodule URL
            SUBMODULE_URL=$(git config --file .gitmodules --get "submodule.$SUBMODULE_PATH.url" || echo "")
            
            if [ -z "$SUBMODULE_URL" ]; then
              echo "Warning: No URL found for submodule $SUBMODULE_PATH"
              continue
            fi
            
            echo "URL: $SUBMODULE_URL"
            
            # Check if remote is accessible using git ls-remote
            if git ls-remote --exit-code "$SUBMODULE_URL" HEAD >/dev/null 2>&1; then
              echo "✓ Remote is accessible"
              
              # Get the branch for this submodule (defaults to remote default branch)
              SUBMODULE_BRANCH=$(git config --file .gitmodules --get "submodule.$SUBMODULE_PATH.branch" || echo "")
              
              # Update the submodule to latest commit on tracked branch
              if [ -n "$SUBMODULE_BRANCH" ]; then
                echo "Updating to latest commit on branch: $SUBMODULE_BRANCH"
                if git -C "$SUBMODULE_PATH" fetch origin "$SUBMODULE_BRANCH" 2>/dev/null; then
                  # Ensure working directory is clean before reset
                  git -C "$SUBMODULE_PATH" reset --hard HEAD
                  git -C "$SUBMODULE_PATH" checkout "$SUBMODULE_BRANCH" 2>/dev/null || \
                    git -C "$SUBMODULE_PATH" checkout -b "$SUBMODULE_BRANCH" "origin/$SUBMODULE_BRANCH"
                  git -C "$SUBMODULE_PATH" reset --hard "origin/$SUBMODULE_BRANCH"
                else
                  echo "Warning: Branch $SUBMODULE_BRANCH not found, skipping update for $SUBMODULE_PATH"
                  continue
                fi
              else
                echo "Updating to latest commit on default branch"
                git -C "$SUBMODULE_PATH" fetch origin
                # Get the default branch name from remote using ls-remote
                DEFAULT_BRANCH=$(git ls-remote --symref "$SUBMODULE_URL" HEAD 2>/dev/null | awk '/^ref:/ {sub(/refs\/heads\//, "", $2); print $2; exit}')
                if [ -z "$DEFAULT_BRANCH" ]; then
                  # Fallback: try to get any branch from remote
                  DEFAULT_BRANCH=$(git ls-remote --heads "$SUBMODULE_URL" 2>/dev/null | head -n1 | awk '{sub(/refs\/heads\//, "", $2); print $2}')
                fi
                if [ -n "$DEFAULT_BRANCH" ]; then
                  echo "Default branch detected: $DEFAULT_BRANCH"
                  # Ensure working directory is clean before reset
                  git -C "$SUBMODULE_PATH" reset --hard HEAD
                  git -C "$SUBMODULE_PATH" checkout "$DEFAULT_BRANCH" 2>/dev/null || \
                    git -C "$SUBMODULE_PATH" checkout -b "$DEFAULT_BRANCH" "origin/$DEFAULT_BRANCH"
                  git -C "$SUBMODULE_PATH" reset --hard "origin/$DEFAULT_BRANCH"
                else
                  echo "No branches found, using detached HEAD at origin/HEAD"
                  git -C "$SUBMODULE_PATH" checkout origin/HEAD
                fi
              fi
              
              # Check if submodule commit changed
              if git diff --quiet HEAD -- "$SUBMODULE_PATH"; then
                echo "No changes in $SUBMODULE_PATH"
              else
                echo "✓ Updated $SUBMODULE_PATH to latest commit"
                git add "$SUBMODULE_PATH"
                CHANGES_MADE=true
              fi
            else
              echo "✗ Remote is not accessible or empty"
              echo "Marking submodule $SUBMODULE_PATH for removal..."
              STALE_SUBMODULES+=("$SUBMODULE_PATH")
            fi
          done
          
          # Remove stale submodules
          if [ ${#STALE_SUBMODULES[@]} -gt 0 ]; then
            echo "----------------------------------------"
            echo "Removing stale submodules..."
            for SUBMODULE_PATH in "${STALE_SUBMODULES[@]}"; do
              echo "Removing stale submodule: $SUBMODULE_PATH"
              
              # Remove from .gitmodules
              git config --file .gitmodules --remove-section "submodule.$SUBMODULE_PATH" 2>/dev/null || true
              
              # Stage .gitmodules changes
              git add .gitmodules
              
              # Remove from .git/config
              git submodule deinit -f "$SUBMODULE_PATH" 2>/dev/null || true
              
              # Remove from working tree and index
              git rm -f "$SUBMODULE_PATH" 2>/dev/null || true
              
              # Remove leftover .git directory if it exists
              rm -rf ".git/modules/$SUBMODULE_PATH" 2>/dev/null || true
              
              CHANGES_MADE=true
              REMOVED_COUNT=$((REMOVED_COUNT + 1))
            done
          fi
          
          # Output result
          if [ "$CHANGES_MADE" = true ]; then
            echo "changes_made=true" >> $GITHUB_OUTPUT
            echo "removed_count=$REMOVED_COUNT" >> $GITHUB_OUTPUT
            echo "----------------------------------------"
            echo "✓ Changes detected and staged"
          else
            echo "changes_made=false" >> $GITHUB_OUTPUT
            echo "removed_count=0" >> $GITHUB_OUTPUT
            echo "----------------------------------------"
            echo "No changes needed"
          fi

      - name: Commit and push changes
        if: steps.update.outputs.changes_made == 'true'
        run: |
          # Check if there are staged changes
          if git diff --staged --quiet; then
            echo "No staged changes to commit"
            exit 0
          fi
          
          # Create commit message
          REMOVED_COUNT="${{ steps.update.outputs.removed_count }}"
          
          if [ "$REMOVED_COUNT" -gt 0 ]; then
            COMMIT_MSG="chore: update submodules to latest commits and remove stale entries"
          else
            COMMIT_MSG="chore: update submodules to latest commits"
          fi
          
          git commit -m "$COMMIT_MSG" -m "Automated update by GitHub Actions"
          git push origin "${{ github.ref_name }}"
          
          echo "✓ Changes committed and pushed successfully"

      - name: Summary
        run: |
          if [ "${{ steps.update.outputs.changes_made }}" = "true" ]; then
            echo "### ✅ Submodules Updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Submodules have been updated to their latest commits." >> $GITHUB_STEP_SUMMARY
            echo "Changes have been committed and pushed to the repository." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ℹ️ No Updates Needed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All submodules are already up to date." >> $GITHUB_STEP_SUMMARY
